REACT NATIVE + EXPO 
PROJECT SETUP

> yarn create expo-app project-name
> yarn start

> a to load on androd
> r to reload

==================================================================================================

By default, every view in React Native uses flexbox, event if
you don't assign any special style (it differs from web dev)

In web dev, if you use flexbox the default is a row orientation
But in Native, the default is a column orientation

==================================================================================================

To allow user interaction, you need to handle EVENTS

CASE FOR ADDING AN ITEM TO A LIST:

const [enteredItem, setEnteredItem] = useState('')

  // enteredItem is the STATE VARIABLE
  // setEnteredItem is a FUNCTION that updates the state variable


function handleEnteredItem(enteredText) {
  setEnteredItem(enteredText)
}

  // a function that injects the text typed by the user into the setEnteredItemText

const [itemsList, setItemsList] = useState([])

  // declares the items list, initially empty

function handleItemsList() {
    setItemsList((currentItemsList) => 
        [...currentItemsList, enteredItem])
}

  // a function that injects another function to the setItemsList
  // the currentItemsList injects the enteredItem to what is already in the list

==================================================================================================

STYLING DIFFERENCES BETWEEN ANDROID AND iOS:

Native is built to allow you to write one code to both devices, 
but you might need to make some tiny fixes to really achieve it

For instance, If you create a <Text> and style it, 
some features might not work on iOS  - like border radius

Many times if you create a <View> to wrap this element,
and style this View and the element inside separately,
it is a good workaround

==================================================================================================

GOOD TO KNOW ABOUT NATIVE DEVELOPMENT:

- In mobile development, we don't have a Document Object Model (DOM) like web,
instead we use frameworks and libraries to manipulate the interface

- In Native, Buttons do not have style props

- Mobile layouts are not auto scrollable like websites
You need to import <ScrollView> and wrap it around the scrollable elements

- ScrollView makes every of its child render, no matter if it is already shown
on the screen or not. It might cause performance issues.

==================================================================================================

<FLATLIST />

- Using <Flatlist> can be a better choice than ScrollView because it only renders what is visible
  And Flatlist itself also renders the list

  Example:

  <FlatList data={itemsList} renderItem={(item) => {}} />

  - The data property tells WHAT data should be rendered
  - The renderItem property tells HOW data should be rendered
    - Its value must be a function
      - Its parameter is itemData, automatically generated by FlatList 
        around each item of the itemsList
      - It carries not only the value but also some metadata
  - The itemData gives access to:
    - itemData.index (0, 1, 2...)
    - itemData.item (the value)
  - With FlatList, no need to use the key prop
    - Instead, make each entered item an object with a text and a key, for instance:
      { text: enteredItem, key: Math.random().toString() }

  So it gets like this:

  <FlatList 
    data={itemsList} 
    renderItem={(itemData) => {
      return (
        <View>
          <Text}>{itemData.item.text}</Text>
        </View>
      )
    }} 
  />
